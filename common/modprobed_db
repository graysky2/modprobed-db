#!/bin/bash
# modprobed_db by graysky
#
# See this wiki article for more details:
# https://wiki.archlinux.org/index.php/Modprobed_db
#
# The purpose of this little script is to keep track of EVERY single module
# that your system has probed over a time period for the purpose of having the
# perfect amount of modules compiled into your kernel via the make localmodconfig
# option.
#
vers="2.20"

if [[ ! -f /usr/share/modprobed_db/modprobed_db.skel ]]; then
	printf '%s\n' "/usr/share/modprobed_db/modprobed_db.skel is missing, please reinstall this package."
	exit 1
fi

# We need to keep book on which user runs this script invoking it via sudo
#
# find user invoking the script
USER=$(logname)

# find user's homedir and use it
homedir="$(awk -F: '{print $6}' <(getent passwd $USER))"
cfg_file=$XDG_CONFIG_HOME/modprobed_db.conf

# default COLORS if undefined are for dark backgrounds
[[ -z "$COLORS" ]] && COLORS="dark"
[[ "$COLORS" = "dark" ]] && export bld=$'\e[01m' \
	red=$'\e[01;31m' \
	grn=$'\e[00;32m' \
	ylw=$'\e[00;34m' \
	nrm=$'\e[0m'
[[ "$COLORS" = "light" ]] && export bld=$'\e[01m' \
	red=$'\e[00;31m' \
	grn=$'\e[00;32m' \
	ylw=$'\e[00;34m' \
	nrm=$'\e[00m'

if [[ ! -f "$cfg_file" ]]; then
	cat <<-EOF
	------------------------------------------------------------
	No config file found so creating a fresh one in:
	$XDG_CONFIG_HOME/modprobed_db.conf
	
	Consult the man page for setup instructions.
	EOF
	if [[ -f /etc/modprobed_db.conf ]]; then
		cat <<-EOF

		${red}Notice:${nrm}
		/etc/modprobed_db.conf was found on your system.
		This file depreciated starting in version 2.19.
		Please diff this file against the freshly created one.
		
		Do NOT just blindly overwrite!
		EOF
	fi
	sed  "s|@HOME@|$homedir|" /usr/share/modprobed_db/modprobed_db.skel >$cfg_file
	printf '%s\n' "------------------------------------------------------------"
	exit 0
else
	. $cfg_file
	db="$DBPATH/modprobed.db"
fi

check() {
	# print out currently loaded modules less those in the IGNORE array
	printf '%s\n' "${IGNORE[@]}" | \
		awk 'FNR == NR {a[$0]; next} !($1 in a) {print $1}' - /proc/modules | \
		sort >/tmp/.inmem

	if [[ ! -f "$db" ]]; then
		# check to see if user can write to $DBPATH
		if [[ -w "$DBPATH" ]]; then
			printf '%b\n' "${bld}No db present so just created one: ${ylw}$db${nrm}"
			if [[ -f /var/log/modprobed.db ]]; then
				cat <<-EOF
				${bld}${red}"NOTICE:"${nrm}
				${bld}${ylw}"/var/log/modprobed.db${nrm}${bld} found on this system."${nrm}
				${bld}"It is recommended that you copy it to ${ylw}$XDG_CONGIG_HOME/modprobed.db"${nrm}
				${bld}"since this is the new default location for the database."${nrm}
				
				${bld}"Once copied, please delete the old ${ylw}/var/log/modprobed.db"${nrm}
				EOF
			fi
			cp /tmp/.inmem "$db"
			exit 0
		else
			cat <<-EOF
			${red}WARNING:${nrm}
			${bld}Cannot create ${ylw}$db${nrm}${bld} since $USER does not have write access to ${ylw}$DBPATH"${nrm}
			
			${bld}Your options:${nrm}
			${bld} 1) Run $0 as root then change owners of the database like this:"${nrm}
			${bld}    # chown $USER:$(id -g -n $(whoami)) $db"${nrm}
			
			${bld} or${nrm}
			
			${bld} 2) Redefine the DBPATH in ${ylw}$CFG_FILE${nrm}${bld} to somewhere $(whoami) can write."${nrm}
			EOF
			exit 1
		fi
	else
		dbsize=$(wc -l <"$db")
		loadsize=$(wc -l </tmp/.inmem)
	fi
}

recall() {
	# since version 2.17 the redundant file is deprecated so remove it
	[[ -f "$DBPATH/modprobed.long" ]] && rm -f $DBPATH/modprobed.long

	if [[ $EUID -ne 0 ]]; then
		printf '%b\n' "${bld}This function must be called as root!${nrm}"
		exit 1
	fi

	# sed statement converts the db to a single, run-on sentence for modprobe
	printf '%b\n' "${bld}Attempting to modprobe the contents of ${ylw}$db${nrm}${bld}"
	modprobe -a $(sed ':a;N;$!ba;s/\n/ /g' "$db")
	# print out currently loaded modules less those in the IGNORE array
	printf '%s\n' "${IGNORE[@]}" | \
		awk 'FNR == NR {a[$0]; next} !($1 in a) {print $1}' - /proc/modules | \
		sort >/tmp/.inmem

	printf '\n%b\n' "${red}$(wc -l </tmp/.inmem)${nrm}${bld} modules are now loaded per ${ylw}/proc/modules${nrm}"
}

debug() {
	printf "%b\n" "${bld}The following are in the database but not loaded:${nrm}"
	grep -Fxvf /tmp/.inmem "$db"
	
	printf "%b\n" "${bld}The following are loaded but not in the database:${nrm}"
	grep -Fxvf "$db" /tmp/.inmem
}

store() {
	if [[ ! -w "$db" ]]; then
		cat <<-EOF
		${red}WARNING:${nrm}
		${bld}Cannot modify ${ylw}$db${nrm}${bld} since $(whoami) does not have write access!"${nrm}
		
		${bld}Your options:${nrm}
		${bld} 1) Change owners of the database like this:"${nrm}
		${bld}    # chown $(whoami):$(id -g -n $(whoami)) $db"${nrm}
		
		${bld} or${nrm}
		
		${bld} 2) Move ${ylw}$db{${nrm}${bld} to somewhere where $(whoami) can write"${nrm}
		${bld}    and redefine the DBPATH in ${ylw}/etc/modprobed_db.conf${nrm}${bld} reflect this new location."${nrm}
		EOF
		exit 1
	fi

	dbcheck=$(md5sum "$db" | cut -c1-32)

	printf '%s\n' "${IGNORE[@]}" | \
		awk 'FNR == NR {a[$0]; next} !($1 in a) {print $1}' - /proc/modules | \
		sort >/tmp/.inmem
	sort -k 1,1 "$db" /tmp/.inmem | uniq > /tmp/.potential_new_db
	newcheck=$(md5sum /tmp/.potential_new_db | cut -c1-32)

	if [[ "$dbcheck" != "$newcheck" ]]; then
		whatsnew=$(grep -Fxvf "$db" /tmp/.potential_new_db)
		printf '%b\n' "${ylw}New module(s) detected:\n${nrm}${bld}$whatsnew${nrm}"
		cp /tmp/.potential_new_db "$db"
		newdbsize=$(wc -l <"$db")
		printf '%b\n' "$newdbsize modules are now saved in ${ylw}$db ${nrm}${bld}"
	else
		printf '%b\n' "${bld}No new modules detected.  Taking no action.${nrm}"
	fi
}

print_modules() {
	printf '%b\n' "${bld}$loadsize modules currently loaded per ${ylw}/proc/modules${nrm}"
	printf '%b\n' "${bld}$dbsize modules are in ${ylw}$db${nrm}"
}

cleanup() {
	[[ -f /tmp/.inmem ]] && rm -f /tmp/.inmem
	[[ -f /tmp/.potential_new_db ]] && rm -f /tmp/.potential_new_db
}

printf '%b\n\n' "${red}Modprobed_db v$vers${nrm}"

check

case $1 in
	l|L|List|list)
		less "$db"; cleanup; exit 0
		;;
	r|R|Recall|recall)
		recall && print_modules; cleanup; exit 0
		;;
	d|D|Debug|debug)
		debug && print_modules; cleanup; exit 0
		;;
	s|S|Store|store)
		store && print_modules; cleanup; exit 0
		;;
	*)
		printf '%b\n' "${bld}$0${nrm}${grn} {list|recall|store|debug}${nrm}"
		printf '%b\n' "${bld}See manpage for additional details${nrm}"
		exit 0
esac
